import enum
from typing import Callable

from aiopubsub import Hub, Key, Publisher, Subscriber

from connectai.modules.datamodel import AgentResponsePayload


class PubSubPublisherType(enum.Enum):
    """Identifies what type of publisher is publishing the info."""

    LLM = "llm"  # For responses generated by LLM
    STATIC = "static"  # For static responses generated by code/config
    OTHER = "other"  # For other types of publishers (if new one needed add another enum value here)
    GENERIC = "*"


class PubSubKey(enum.Enum):
    """Identifies what type of info is being published."""

    RESPONSE = "response"  # For responses
    RESPONSE_COMPLETED = "response_completed"  # For responses
    STATE_CLASSIFIER = "state_classifier"  # For classifier responses
    RETRIEVER = "retriever"  # For retriever responses
    OTHER = "other"  # For other types of publishers (if new one needed add another enum value here)
    GENERIC = "*"


class PubSubKeyType(enum.Enum):
    """Identifies what type of message is being sent for the defined key (e.g. Key:

    message, KeyType: could be either "chunk" or "full_message").
    """

    CHUNK = "chunk"  # For chunks of responses (parts of string messages)
    FULL_MESSAGE = "full_message"  # For full responses
    OTHER = "other"  # For other types of publishers (if new one needed add another enum value here)
    GENERIC = "*"


class PublicPubSub:
    """A shared PubSub class to manage in memory async publishers and subscribers."""

    def __init__(self) -> None:
        """Initialize the PubSub hub, publishers, and subscribers."""
        self.pubsub_hub = Hub()
        self.publishers: dict[PubSubPublisherType, Publisher] = {}
        self.subscribers: dict[str, Subscriber] = {}

    def get_or_create_publisher(self, publisher_type: PubSubPublisherType) -> Publisher:
        """Get or create a Publisher for the given type.

        Args:
            publisher_type (PubSubPublisherType): The type of the publisher.

        Returns:
            Publisher: The publisher instance for the specified type.
        """
        if publisher_type not in self.publishers:
            self.publishers[publisher_type] = Publisher(self.pubsub_hub, prefix=Key(publisher_type.value))
        return self.publishers[publisher_type]

    def get_or_create_subscriber(self, subscriber_id: str) -> Subscriber:
        """Get or create a Subscriber for the given ID.

        Args:
            subscriber_id (str): The unique ID of the subscriber.

        Returns:
            Subscriber: The subscriber instance for the specified ID.
        """
        if subscriber_id not in self.subscribers:
            self.subscribers[subscriber_id] = Subscriber(self.pubsub_hub, subscriber_id)
        return self.subscribers[subscriber_id]

    def publish(
        self,
        publisher_type: PubSubPublisherType,
        key: PubSubKey,
        key_type: PubSubKeyType,
        message: AgentResponsePayload,
    ) -> None:
        """Publish a message to the specified topic.

        Args:
            publisher_type (PubSubPublisherType): The type of the publisher.
            key (PubSubKey): The key identifying the topic.
            key_type (PubSubKeyType): The type of the message.
            message (str): The string formatted message to be published.
        """
        publisher = self.get_or_create_publisher(publisher_type)
        publisher.publish(Key(key.value, key_type.value), message)

    def subscribe(
        self,
        subscriber_id: str,
        publisher_type: PubSubPublisherType,
        key: PubSubKey,
        key_type: PubSubKeyType,
        callback: Callable,
    ) -> None:
        """Subscribe to a specific topic with a callback.

        Args:
            subscriber_id (str): The unique ID of the subscriber.
            publisher_type (PubSubPublisherType): The type of the publisher.
            key (PubSubKey): The key identifying the topic.
            key_type (PubSubKeyType): The type of the message.
            callback (Callable): The asynchronous callback function to handle messages.
        """
        subscriber = self.get_or_create_subscriber(subscriber_id)
        subscribe_key = Key(publisher_type.value, key.value, key_type.value)
        subscriber.subscribe(key=subscribe_key)
        subscriber.add_sync_listener(subscribe_key, callback)

    async def clear_async_listeners(self) -> None:
        """Clear all async listeners for all subscribers to avoid memory leaks."""
        for subscriber in self.subscribers.values():
            await subscriber.remove_all_listeners()
